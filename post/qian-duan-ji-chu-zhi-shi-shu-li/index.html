<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>前端基础知识梳理 | Why&#39;s Blog</title>
<meta name="description" content="" />
<link rel="shortcut icon" href="https://blog.callmewhy.com/favicon.ico?v=1606396339938">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://blog.callmewhy.com/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-92598519-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-92598519-1');
</script>


  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://blog.callmewhy.com">
  <img class="avatar" src="https://blog.callmewhy.com/images/avatar.png?v=1606396339938" alt="">
  </a>
  <h1 class="site-title">
    Why&#39;s Blog
  </h1>
  <p class="site-description">
    
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/callmewhy" target="_blank">
          <i class="fab fa-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              前端基础知识梳理
            </h2>
            <div class="post-info">
              <span>
                2019-05-08
              </span>
              <span>
                16 min read
              </span>
              
                <a href="https://blog.callmewhy.com/tag/WZhN7vCZ4R/" class="post-tag">
                  # Frontend
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h2 id="css">CSS</h2>
<h3 id="几种布局">几种布局</h3>
<ul>
<li>正常布局流，display 属性为 block inline inline-block 这些标准属性，是浏览器默认的HTML布局方式</li>
<li>table 布局，优点是兼容性好，缺点是需要等内容全部加载完才可以展示</li>
<li>浮动布局，通过 float 属性，例如 float: left 可以让块级元素并排而不是堆叠</li>
<li>position 属性布局
<ul>
<li>静态定位 static：默认属性</li>
<li>相对定位 relative：允许元素的相对移动</li>
<li>静态定位 absolute：相对第一个非 static 的父类元素定位</li>
<li>固定定位 fixed：相对浏览器视图固定</li>
<li>粘性布局 sticky：指定阈值后，未越过阈值为 relative，越过阈值为 fixed</li>
</ul>
</li>
<li>CSS Grid，display 属性为 grid，兼容性差</li>
<li>Flexbox，display 属性为 flex</li>
</ul>
<h3 id="盒模型">盒模型</h3>
<ul>
<li>content、padding、border、border</li>
<li>标准盒模型（content-box）的宽高就是 content 的宽高，IE 盒模型（border-box）的宽高是 content+padding+border 宽高的总和</li>
</ul>
<h3 id="选择器及其优先级">选择器及其优先级</h3>
<ul>
<li>!important</li>
<li>内联样式 style=&quot;&quot;</li>
<li>ID 选择器 #id</li>
<li>类选择器/属性选择器/伪类选择器</li>
<li>元素选择器/关系选择器/伪元素选择器</li>
<li>通配符选择器</li>
</ul>
<h3 id="bfc">BFC</h3>
<p>Formatting Context 指一个独立的渲染区域，或者说是一个隔离的独立容器。<br>
常见的 Formatting Context：</p>
<ul>
<li>BFC（Block formatting contexts）：块级格式上下文</li>
<li>IFC（Inline formatting contexts）：内联格式上下文</li>
<li>GFC（GrideLayout formatting contexts）：网格布局格式化上下文</li>
<li>FFC（Flex formatting contexts）：自适应格式上下文</li>
</ul>
<p>BFC（Block Formatting Context）是一个用来管理块级元素的容器，是 Web 页面中盒模型布局的 CSS 渲染模式。</p>
<ul>
<li>内部的 Box 会在垂直方向上一个接一个地放置，垂直方向的距离由 margin 决定</li>
<li>属于同一个 BFC 的两个相邻的块级元素的 margin 会发生重叠</li>
<li>每个元素的 margin box 的左边， 与包含块 border box 的左边相接触。即使存在浮动也是如此</li>
<li>BFC 的区域不会与 float 的元素区域重叠</li>
<li>计算 BFC 的高度时，浮动子元素也参与计算</li>
<li>BFC 是隔离的独立容器，容器里面的子元素不会影响到外面元素</li>
</ul>
<p>BFC 主要的作用是：</p>
<ul>
<li>清除浮动，比如实现左边侧边栏的效果</li>
<li>防止同一 BFC 容器中的相邻元素间的外边距重叠问题</li>
</ul>
<h3 id="伪类和伪元素">伪类和伪元素</h3>
<p>伪类（一个冒号）</p>
<ul>
<li>获取不存在与DOM树中的信息。比如a标签的:link、visited等，这些信息不存在与DOM树结构中，只能通过CSS选择器来获取；</li>
<li>获取不能被常规CSS选择器获取的信息。比如：要获取第一个子元素，我们无法用常规的CSS选择器获取，但可以通过 :first-child 来获取到。</li>
</ul>
<p>伪元素（两个冒号，CSS3 中区分开）</p>
<ul>
<li>伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。常见的伪元素有 ::before、::after 等</li>
</ul>
<h3 id="清理浮动">清理浮动</h3>
<ul>
<li>原因：浮动会导致父容器高度塌陷</li>
<li>方案1：在父元素末尾添加冗余的块级元素，设置 <code>clear: both</code></li>
<li>方案2：通过伪元素 <code>:after</code> 添加一个看不见的块元素，推荐方案</li>
<li>方案3：给父元素设置 <code>overflow: hidden</code> ，将它变成 BFC，可以包含浮动</li>
</ul>
<h3 id="移动端适配">移动端适配</h3>
<ul>
<li>rem 做单位，根据视图大小来改变根元素字体大小</li>
<li>vw 做单位，可以按设计稿的像素开发，缺点是跟随 viewport 放大缩小，没有最大最小值的限制</li>
</ul>
<h3 id="setinterval-和-requestanimationframe">setInterval 和 requestAnimationFrame</h3>
<ul>
<li>setInterval 是从开始时间计时，无法确保执行间隔。由定时触发器线程执行定时，由事件触发线程塞进任务队列的尾部，由 JS 引擎的主线程来执行，不会重复放入事件队列中，如果主线程阻塞，且队列中已经存在了一个定时器，则下一次会直接跳过计时。主线程执行结束后，会立即执行队列中的定时器。</li>
<li>requestAnimationFrame 由系统来决定回调函数的执行时机，能保证回调函数在屏幕每一次的刷新间隔中只被执行一次。有两个优点：与屏幕渲染一致，所以更加节能；有函数节流的效果。</li>
</ul>
<h2 id="javascript">JavaScript</h2>
<h3 id="七种数据类型">七种数据类型</h3>
<ul>
<li>Undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>String</li>
<li>Number</li>
<li>Symbol</li>
<li>Object（包括数组、函数、正则、日期）</li>
</ul>
<h3 id="判断数据类型的方法重要">判断数据类型的方法（重要）</h3>
<ul>
<li>typeof：JS 在底层存储变量的时候，会在变量的机器码的低位 1-3 位存储其类型信息，number（010）, string（100）, object（000）, boolean（110）, undefined（-2^30），null ：所有机器码为0
<ul>
<li>优点：能够快速区分基本数据类型，包括 function（通过是否实现 call 方法判断）</li>
<li>缺点：不能将 Object、Array 和 Null 区分，都返回 object</li>
</ul>
</li>
<li>instanceof：判断一个实例是否属于某种类型，检查左边实例的 <code>__proto__</code> 和右边类的 prototype 是否在同一条原型链上
<ul>
<li>优点：可以用来判断对象的具体类型</li>
<li>缺点：Number，Boolean，String 基本数据类型不能判断；多个 iframe 中判断不准确</li>
</ul>
</li>
<li>constructor：通过构造函数比较来判断
<ul>
<li>优点：可以判断基本数据类型</li>
<li>缺点：无法判断 null 和 undefined，构造函数本身可被覆盖，不够稳定</li>
</ul>
</li>
<li><code>Object.prototype.toString.call</code> 准确判断对象实例的类型</li>
</ul>
<h3 id="原型对象">原型对象</h3>
<p>每个函数都会有一个 prototye 属性指向函数的原型对象，每个原型对象都会获取一个 constructor 属性指向构造函数，即：Function.prototype.constructor == Function</p>
<h3 id="new-运算符的原理">new 运算符的原理</h3>
<ul>
<li>创建一个空对象，它的 <code>__proto__</code> 等于构造函数的原型对象（可以用Object.create()完成）</li>
<li>构造函数以第1步创建的对象做为上下文，是否会返回一个对象</li>
<li>若第2步返回了对象，则使用该对象作为新实例，否则用第1步创建的对象作为新实例</li>
</ul>
<pre><code class="language-js">function myNew(func) {
    var o = Object.create(func.prototype)
    var i = func.call(o)
    return typeof i === 'object' ? i : o
}
</code></pre>
<h3 id="继承的几种实现方式重要">继承的几种实现方式（重要）</h3>
<ul>
<li>原型链继承：<code>B.prototype = new A()</code>
<ul>
<li>缺点：引用类型的属性会被所有子类共享，创建子类实例时父类构造函数无法传参</li>
</ul>
</li>
<li>构造函数继承：<code>function B(params) { A.call(this, params) }</code>
<ul>
<li>缺点：只能继承构造函数内的实例属性；无法获取父类原型链的属性；无法复用函数，每个子类都是独立副本</li>
</ul>
</li>
<li>原型链+构造函数
<ul>
<li>缺点：调用了两次父类构造函数</li>
</ul>
</li>
<li>Class 实现继承，需要 ES6 支持</li>
<li>原型链+构造函数优化</li>
</ul>
<pre><code class="language-js">function B(params) {
    A.call(this, ...params)
}
B.prototype = Object.create(A.prototype)
B.prototype.constructor = B
</code></pre>
<h3 id="call-apply-和-bind-区别">call、apply 和 bind 区别</h3>
<p>三个函数的作用都是将函数绑定到上下文中，用来改变函数中 this 的指向</p>
<pre><code class="language-js">// call 方法接受的是若干个参数列表
fun.call(thisArg[, arg1[, arg2[, ...]]])
// apply 接收的是一个包含多个参数的数组
fun.apply(thisArg, [argsArray])
// bind 会创建一个新的函数
var bindFn = fun.bind(thisArg[, arg1[, arg2[, ...]]])
bindFn()
</code></pre>
<h3 id="防抖debouncing和节流throttling重要">防抖（Debouncing）和节流（Throttling）（重要）</h3>
<ul>
<li>防抖（Debouncing）：将触发频繁的事件合并成一次执行。适用场景： input 实时反馈、scroll 事件优化。</li>
<li>节流（Throttling）： 设置一个阀值，在阀值内，将触发的事件合并成一次执行，且当到达阀值，必定执行一次事件。防止浏览器频繁响应事件，严重拉低性能。适用场景：resize 事件、鼠标移动事件</li>
</ul>
<h3 id="模块化的实现">模块化的实现</h3>
<ul>
<li>CommonJS：主要用于 NodeJS，同步加载，文件即模块，导出的是值的拷贝。通过 <code>exports</code> <code>require</code> 导出和加载，加载后会在内存里生成一个对象，引入时会去 <code>exports</code> 属性上取值，所以只会加载一次。浏览器端需要通过 browserify 进行打包。输出的是值的拷贝。</li>
<li>AMD：在模块开始时异步加载所有依赖模块，全量加载，可以并行</li>
<li>CMD：类似 CommonJS 的风格，动态引入，按需加载，延迟执行</li>
<li>ES6：在语言标准的层面实现了模块功能，模块是一个单例，通过 <code>import</code> <code>export</code> 导出和加载，输出的是值的引用。</li>
</ul>
<h2 id="其他">其他</h2>
<h3 id="浏览器缓存策略重要">浏览器缓存策略（重要）</h3>
<p>缓存流程：</p>
<ul>
<li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li>
<li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li>
</ul>
<p>缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。</p>
<ul>
<li>强制缓存：不发送请求，直接读取缓存，通过设置两种 HTTP Header 控制：Expires（HTTP/1.0）和 Cache-Control（HTTP/1.1），强制缓存生效会返回 200 状态码。</li>
<li>协商缓存：强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存
<ul>
<li>两种结果：
<ul>
<li>生效返回 304，还是由客户端从缓存读取</li>
<li>失效返回 200，服务器返回最新结果</li>
</ul>
</li>
<li>两种方式：
<ul>
<li>Last-Modified 和 If-Modified-Since：标记最后修改时间，缺点是不够精确，只能精确到秒</li>
<li>ETag 和 If-None-Match：由服务器生成当前资源的唯一标识<br>
<img src="https://blog.callmewhy.com/post-images/1578713476462.jpeg" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="web-worker">Web Worker</h3>
<p>Web Worker 为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p>
<ul>
<li>同源限制：Worker 线程的脚本文件必须和主线程脚本文件同源</li>
<li>DOM 限制，无法获取 document window ，可以获取 navigator 和 location</li>
<li>通信限制：无法与主线程直接通信，必须通过消息完成，主线程 <code>postMessage</code> ，worker 线程 <code>onmessage</code> 监听</li>
<li>脚本限制：无法执行 alert confirm 函数，但是可以发送 ajax 请求</li>
<li>文件限制：无法读取本地文件，脚本来源自网络</li>
<li>应用场景：后台轮询</li>
</ul>
<h3 id="pwa-progressive-web-app">PWA - Progressive Web App</h3>
<p>PWA 经过应用一些新技术进行改进，在安全、性能和体验三个方面提升 Web 体验，本质上还是 Web App。<br>
改造方式：</p>
<ul>
<li>全站 HTTPS 化，这是 PWA 的基础，没有 HTTPS 就没有 Service Worker</li>
<li>通过 Service Worker 提升基础性能，离线提供静态文件，提升用户首屏体验</li>
<li>App Manifest 同步进行</li>
<li>考虑其他的特性，离线消息推送等</li>
</ul>
<h3 id="script-标签解析">script 标签解析</h3>
<ul>
<li>默认情况，会立即加载并执行指定的脚本，不等待标签后面的文档加载完毕</li>
<li>async defer 共同点：开新线程并行下载，不会阻塞解析</li>
<li>async：下载完成后立即执行，执行时会阻塞文档解析，无法确保顺序，适合 GA 这种无依赖脚本</li>
<li>defer：所有文档元素加载完成之后按照顺序执行，在 DOMContentLoaded 事件触发之前完成</li>
<li>动态添加的 script 标签隐含 async 属性</li>
</ul>
<h3 id="preload-和-prefetch">preload 和 prefetch</h3>
<ul>
<li>preload 预加载本次导航可能用到的资源，优先级根据 as 属性决定，加载资源存储在缓存里，下次请求直接读取缓存，不会重复请求资源，跳转的时候未完成的任务会取消，主要目的是提前做好缓存。</li>
<li>prefetch 预加载下次导航可能用到的资源，优先级最低，不保证缓存资源，所以多次请求会重复请求，导航到其他页面的时候未完成的请求也会保持。</li>
</ul>
<h3 id="cookie-特性">Cookie 特性</h3>
<ul>
<li>通过 domain 限制域名，通过 path 限制路径，通过 Expires/Max-Age 限制有效期</li>
<li>cookie 本身没有删除，通过设置 Max-Age 为 0 可以让 cookie 失效删除</li>
<li>HttpOnly 字段设置为 true ，则 JS 无法获取 cookie 的值，可以防止 XSS 攻击</li>
<li>document.cookie 获取和修改 cookie ，是一个字符串，分号分割</li>
</ul>
<h3 id="性能优化方案重要">性能优化方案（重要）</h3>
<ul>
<li>网络优化
<ul>
<li>使用 CDN</li>
<li>升级 HTTP/2</li>
<li>使用缓存（强制缓存和协商缓存）</li>
</ul>
</li>
<li>资源优化
<ul>
<li>preloader、prefetch、async、defer 等相关指令</li>
<li>资源域名拆分，避免浏览器 TCP 连接数限制</li>
<li>资源压缩与合并</li>
</ul>
</li>
<li>渲染优化
<ul>
<li>减少 DOM 操作</li>
<li>图片指定宽高</li>
<li>避免重排重绘</li>
</ul>
</li>
</ul>
<h3 id="图片懒加载实现原理">图片懒加载实现原理</h3>
<ul>
<li>用 data-src 存储图片地址，初始化的时候图片无内容，监听 scroll 事件，执行防抖函数滞后执行避免掉帧，通过 getBoundingClientRect 判断图片是否出现在屏幕中，在展示的时候再加载图片。</li>
<li>判断图片是否展示也可以通过 IntersectionObserver 实现。</li>
<li>Chrome 已经官方支持 <a href="https://web.dev/native-lazy-loading">Lazy Load</a>，在 img 标签加上  loading=&quot;lazy&quot; 即可。</li>
</ul>
<h3 id="cdn-的工作原理">CDN 的工作原理</h3>
<p>Content Delivery Network，缩写 CDN，将网站的内容发布到最接近用户的网络节点，使用户可以就近取得所需内容，提高用户访问网站的响应速度。一般通过修改 DNS 实现，利用 CNAME 将域名和目标 IP 之间进行解耦。</p>
<p>核心：</p>
<ul>
<li>缓存：将从根服务器请求来的资源按要求缓存</li>
<li>回源：当有用户访问某个资源的时候，如果被解析到的那个 CDN 节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取。没有人访问，CDN 节点不会主动去源站请求资源。</li>
</ul>
<p>优点：</p>
<ul>
<li>加速：通过靠近用户的网络节点降低访问延时</li>
<li>负载：分流减轻源站的负载</li>
</ul>
<h3 id="安全概念重要">安全概念（重要）</h3>
<ul>
<li>CSRF：Cross-Site Request Forgery，跨站请求伪造，挟持用户在当前已登录的 Web 应用程序上执行非本意的操作，比如通过 <code>&lt;img src=&quot;https://t.cn/withdraw?account=xx&amp;amount=xx&quot;&gt;</code> 伪造请求
<ul>
<li>防御措施：Token 验证和 Referer 验证</li>
</ul>
</li>
<li>XSS：Cross Site Script，跨域脚本攻击，类似 SQL 注入
<ul>
<li>三种方式：
<ul>
<li>DOM based XSS：DOM 型，不经过后端，URL -&gt; 浏览器</li>
<li>Reflected XSS：反射型，不经过数据库，浏览器 -&gt; 后端 -&gt; 浏览器</li>
<li>Stored XSS：存储型，经过数据库，浏览器 -&gt; 后端 -&gt; 数据库 -&gt; 后端 -&gt; 浏览器</li>
</ul>
</li>
<li>防御措施：cookie 设置 httpOnly 防止读取和篡改，对服务端请求做过滤和转义</li>
</ul>
</li>
</ul>
<h3 id="为什么会有-options-请求">为什么会有 OPTIONS 请求</h3>
<p>规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。</p>
<ul>
<li>获取服务器支持的 HTTP 请求方法；</li>
<li>用来检查服务器的性能。例如：AJAX 进行跨域请求时的预检，需要向另外一个域名的资源发送一个 HTTP OPTIONS 请求头，用以判断实际发送的请求是否安全。</li>
</ul>
<p>当请求满足下述任一条件时，即应首先发送预检请求（使用 OPTIONS）：</p>
<ul>
<li>使用了下面任一 HTTP 方法：
<ul>
<li>PUT</li>
<li>DELETE</li>
<li>CONNECT</li>
<li>OPTIONS</li>
<li>TRACE</li>
<li>PATCH</li>
</ul>
</li>
<li>人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为：
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type (but note the additional requirements below)</li>
<li>DPR</li>
<li>Downlink</li>
<li>Save-Data</li>
<li>Viewport-Width</li>
<li>Width</li>
</ul>
</li>
<li>Content-Type 的值不属于下列之一:
<ul>
<li>application/x-www-form-urlencoded</li>
<li>multipart/form-data</li>
<li>text/plain</li>
</ul>
</li>
</ul>
<hr>
<p>参考资料</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html">Web Worker 使用教程</a></li>
<li><a href="https://www.infoq.cn/article/CS9-WZQlNR5h05HHDo1b">史上最全！图解浏览器的工作原理</a></li>
<li><a href="https://juejin.im/post/5c6a732151882528735f2d33">原来 JavaScript 是这样运行的</a></li>
<li><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">Tasks, microtasks, queues and schedules</a></li>
<li><a href="https://dev.to/lydiahallie/javascript-visualized-prototypal-inheritance-47co">JavaScript Visualized: Prototypal Inheritance</a></li>
<li><a href="https://lavas.baidu.com/pwa/">PWA - Lavas Baidu</a></li>
<li><a href="https://juejin.im/post/5c32ac69f265da6150649ec2">深入浅出浏览器缓存机制</a></li>
<li><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">Tasks, microtasks, queues and schedules</a></li>
<li><a href="https://www.cnblogs.com/wengxuesong/archive/2016/05/16/5497653.html">使用 VH 和 VW 实现真正的流体排版</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ">HTTP 缓存</a></li>
<li><a href="https://mp.weixin.qq.com/s/Uxtm-z48FnhK13Zbm15Tcw">深入浅出 JS 模块化</a></li>
</ul>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#css">CSS</a>
<ul>
<li><a href="#%E5%87%A0%E7%A7%8D%E5%B8%83%E5%B1%80">几种布局</a></li>
<li><a href="#%E7%9B%92%E6%A8%A1%E5%9E%8B">盒模型</a></li>
<li><a href="#%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E5%85%B6%E4%BC%98%E5%85%88%E7%BA%A7">选择器及其优先级</a></li>
<li><a href="#bfc">BFC</a></li>
<li><a href="#%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0">伪类和伪元素</a></li>
<li><a href="#%E6%B8%85%E7%90%86%E6%B5%AE%E5%8A%A8">清理浮动</a></li>
<li><a href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D">移动端适配</a></li>
<li><a href="#setinterval-%E5%92%8C-requestanimationframe">setInterval 和 requestAnimationFrame</a></li>
</ul>
</li>
<li><a href="#javascript">JavaScript</a>
<ul>
<li><a href="#%E4%B8%83%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">七种数据类型</a></li>
<li><a href="#%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95%E9%87%8D%E8%A6%81">判断数据类型的方法（重要）</a></li>
<li><a href="#%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1">原型对象</a></li>
<li><a href="#new-%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%8E%9F%E7%90%86">new 运算符的原理</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E9%87%8D%E8%A6%81">继承的几种实现方式（重要）</a></li>
<li><a href="#call-apply-%E5%92%8C-bind-%E5%8C%BA%E5%88%AB">call、apply 和 bind 区别</a></li>
<li><a href="#%E9%98%B2%E6%8A%96debouncing%E5%92%8C%E8%8A%82%E6%B5%81throttling%E9%87%8D%E8%A6%81">防抖（Debouncing）和节流（Throttling）（重要）</a></li>
<li><a href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0">模块化的实现</a></li>
</ul>
</li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a>
<ul>
<li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E9%87%8D%E8%A6%81">浏览器缓存策略（重要）</a></li>
<li><a href="#web-worker">Web Worker</a></li>
<li><a href="#pwa-progressive-web-app">PWA - Progressive Web App</a></li>
<li><a href="#script-%E6%A0%87%E7%AD%BE%E8%A7%A3%E6%9E%90">script 标签解析</a></li>
<li><a href="#preload-%E5%92%8C-prefetch">preload 和 prefetch</a></li>
<li><a href="#cookie-%E7%89%B9%E6%80%A7">Cookie 特性</a></li>
<li><a href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E9%87%8D%E8%A6%81">性能优化方案（重要）</a></li>
<li><a href="#%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">图片懒加载实现原理</a></li>
<li><a href="#cdn-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">CDN 的工作原理</a></li>
<li><a href="#%E5%AE%89%E5%85%A8%E6%A6%82%E5%BF%B5%E9%87%8D%E8%A6%81">安全概念（重要）</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89-options-%E8%AF%B7%E6%B1%82">为什么会有 OPTIONS 请求</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://blog.callmewhy.com/post/xi-tong-she-ji-mian-shi-ti-xue-xi-bi-ji/">
              <h3 class="post-title">
                系统设计学习笔记
              </h3>
            </a>
          </div>
        

        
          

          
            <link rel="stylesheet" href="https://unpkg.com/disqusjs@1.1/dist/disqusjs.css">
<script src="https://unpkg.com/disqusjs@1.1/dist/disqus.js"></script>

<div id="disqus_thread"></div>

<script>

var options = {
  shortname: 'callmewhy',
  apikey: '',
}
if ('') {
  options.api = ''
}
var dsqjs = new DisqusJS(options)

</script>

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://blog.callmewhy.com/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
